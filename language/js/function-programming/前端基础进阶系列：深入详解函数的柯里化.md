# 前端基础进阶系列：深入详解函数的柯里化

---

[TOC]

## 函数的隐式转换

---

- 先来一道简单的思考题。

```javascript
function fn() {
  return 20
}

console.log(fn + 10); // 输出结果是多少?

// 结果
// function fn() {
//     return 20
// }10
```

- 稍微修改一下, 再想想输出结果会是什么?

```javascript
function fn() {
  return 20
}

fn.toString = function () {
  return 10
}

console.log(fn + 10); // 输出结果是多少?

// 结果
// 20
```

还可以继续修改一下。

```javascript
function fn () {
  return 20
}

fn.toString = function () {
  return 10
}

fn.valueOf = function () {
  return 5
}

console.log(fn + 10); // 输出结果是多少?

// 结果
// 15
```

当使用 console.log, 或者进行运算时, 隐式转换就可能会发生。从上面三个例子中我们可以得出一些关于函数隐式转换的结论。

> 当我们没有重新定义 toString 与 valueOf 时, 函数的隐式转换会调用默认的 toString 方法, 它会将函数的定义内容作为字符串返回。而当我们主动定义了 `toString/valueOf` 方法时, 那么隐式转换的返回结果则由我们自己控制了。其中 `valueOf` 的优先级会比 `toString` 高一点。

## 二、利用 call/apply 封装数组的 map 方法

---

> map(): 对数组中的每一项运行给定函数, 返回每次函数调用的结果组成数组。

```javascript
// 回调函数中有三个参数
// 第一个参数表示 newArr 的每一项,
// 第二个参数表示该项在数组中的索引值,
// 第三个参数表示数组本身

// 除此之外, 回调函数中的 this, 当 map 不存在第二个参数的时候, this指向丢失(即指向 window),
// 当存在第二个参数时, 指向参数所设定的对象
var newArr = [1, 2, 3, 4].map(function (item, index, arr) {
  console.log(item, index, arr, this); // 1 0 [1, 2, 3, 4] Object {a: 1} (第一行结果)
  return item + 1 // 每项加1
}, { a: 1 })

console.log(newArr); // [2, 3, 4, 5]
```

尝试:

```javascript
Array.prototype._map = function (fn, context) {
  var temp = []
  if (typeof fn === 'function') {
    var k = 0
    var len = this.length

    // 封装 for 循环过程
    for (; k < len; k++) {
      console.log(this[k], k, this);
      temp.push(fn.call(context, this[k], k, this))
    }
  } else {
    console.error('TypeError: ' + fn + ' is not a function');
  }

  console.log('temp: ', temp);
  // 返回每一项运算结果组成的新数组
  return temp
}

var newArr = [1, 2, 3, 4]._map(function (item) {
  return item + 1
})

// [2, 3, 4, 5]
```
