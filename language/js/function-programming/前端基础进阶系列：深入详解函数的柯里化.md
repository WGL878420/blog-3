# 前端基础进阶系列：深入详解函数的柯里化

---

[TOC]

## 函数的隐式转换

---

- 先来一道简单的思考题。

```javascript
function fn() {
  return 20
}

console.log(fn + 10); // 输出结果是多少?

// 结果
// function fn() {
//     return 20
// }10
```

- 稍微修改一下, 再想想输出结果会是什么?

```javascript
function fn() {
  return 20
}

fn.toString = function () {
  return 10
}

console.log(fn + 10); // 输出结果是多少?

// 结果
// 20
```

还可以继续修改一下。

```javascript
function fn () {
  return 20
}

fn.toString = function () {
  return 10
}

fn.valueOf = function () {
  return 5
}

console.log(fn + 10); // 输出结果是多少?

// 结果
// 15
```

当使用 console.log, 或者进行运算时, 隐式转换就可能会发生。从上面三个例子中我们可以得出一些关于函数隐式转换的结论。

> 当我们没有重新定义 toString 与 valueOf 时, 函数的隐式转换会调用默认的 toString 方法, 它会将函数的定义内容作为字符串返回。而当我们主动定义了 `toString/valueOf` 方法时, 那么隐式转换的返回结果则由我们自己控制了。其中 `valueOf` 的优先级会比 `toString` 高一点。

## 二、利用 call/apply 封装数组的 map 方法

---
